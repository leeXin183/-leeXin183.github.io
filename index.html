<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="热爱游戏开发">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="热爱游戏开发">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LeeXin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/13/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/13/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" itemprop="url">协程的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-13T23:10:13+08:00">
                2020-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>协程(coroutine)在unity里面一直扮演着十分重要的角色，本人也常常用来设置敌人的状态、计时器或者说某些事件特定触发和分散复杂操作等，但很少探究协程是如何去实现的，原理是什么，在这里便整理一下<br>在研究协程的原理之前我们先注意协程的一些要点：</p>
<p>1.Unity主线程可以理解为其生命周期一个流程，常用如下<br>Awake()：唤醒事件，游戏一开始运行就执行，只执行一次。</p>
<p>OnEnable()：启用事件，只执行一次。当脚本组件被启用的时候执行一次。</p>
<p>Start()：开始事件，执行一次。</p>
<p>FixedUpdate()：固定更新事件，执行N次，0.02秒执行一次。所有物理组件相关的更新都在这个事件中处理。</p>
<p>Update()：更新事件，执行N次，每帧执行一次。</p>
<p>LateUpdate()：稍后更新事件，执行N次，在 Update() 事件执行完毕后再执行。</p>
<p>OnGUI()：GUI渲染事件，执行N次，执行的次数是 Update() 事件的两倍。</p>
<p>OnDisable()：禁用事件，执行一次。在 OnDestroy() 事件前执行。或者当该脚本组件被“禁用”后，也会触发该事件。</p>
<p>OnDestroy()：销毁事件，执行一次。当脚本所挂载的游戏物体被销毁时执行。</p>
<p>2.协程是在主线程中运行的一种伪多线程，他将代码块独立开来，每次执行到yield被挂起，然后下次开始是又yield决定，内部需要一个类似栈的结构来保存协程当前数据，以便下次使用<br>在Unity3D中，协程是可自行停止运行 (yield)，直到给定的 YieldInstruction 结束再继续运行的函数。 协程 (Coroutines) 的不同用途：</p>
<p>• yield; 在下一帧上调用所有 Update 函数后，协同程序将继续运行。</p>
<p>• yield WaitForSeconds(2); 在指定的时间延迟之后，为此帧调用所有 Update 函数之后继续运行</p>
<p>• yield WaitForFixedUpdate(); 在所有脚本上调用所有 FixedUpdate 后继续运行</p>
<p>• yield WWW 完成 WWW 下载后继续运行。</p>
<p>• yield StartCoroutine(MyFunc); 连接协同程序，并等待 MyFunc coroutine 首先结束。</p>
<p>也就是说，将代码段分散在不同的帧中，每次执行一段，下一帧再执行yield挂起的地方。</p>
<p>3.unity是单线程设计，如果new Thread创建新线程来调用UnityAPI比如创建一个GameObject，则会报错,Unity主循环是单线程，游戏脚本MonoBehavior有着严格的生命周期,倾向使用time slicing（时间分片）的协程（coroutine）去完成异步任务,</p>
<p>扯了这么多，我们已经大致了解协程的作用，接下来我们可以去探究一下协程的原理<br>1.迭代器<br>首先，每次编写协程时我们都要先返回一个迭代器IEnumerator</p>
<p>ps:<br>线程是操作系统级别的概念，现代操作系统都实现并且支持线程，线程的调度对应用开发者是透明的，开发者无法预期某线程在何时被调度执行。基于此，一般那种随机出现的BUG，多与线程调度相关。</p>
<p>参考<br><a href="https://blog.csdn.net/qq_15020543/article/details/83956945" target="_blank" rel="noopener">https://blog.csdn.net/qq_15020543/article/details/83956945</a><br><a href="https://www.jianshu.com/p/c958a3331169" target="_blank" rel="noopener">https://www.jianshu.com/p/c958a3331169</a><br><a href="https://www.cnblogs.com/yespi/p/9847533.html" target="_blank" rel="noopener">https://www.cnblogs.com/yespi/p/9847533.html</a><br><a href="https://www.cnblogs.com/zhaodahai/p/6831461.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaodahai/p/6831461.html</a><br><a href="https://www.sohu.com/a/124163126_466876" target="_blank" rel="noopener">https://www.sohu.com/a/124163126_466876</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/08/Mipmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/08/Mipmap/" itemprop="url">Mipmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-08T21:59:05+08:00">
                2020-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/08/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/08/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" itemprop="url">值类型和引用类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-08T21:01:37+08:00">
                2020-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>值类型就是int,long等直接表示数据的类型，存储在栈上，由系统自动释放。对于struct，我在讲述结构体与class的使用场景探究是有详细说明，有兴趣的同学可以看看《struct和class》，<br>还有enum，用状态值表示int。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型存放数据的引用，比如class,interface,delegate。还有内置的一些引用类型，比如string,object,dynamic。对于委托可以看另一篇文章《C#委托探究》，dynamic是一个动态类型，和object差不多，可以和所有类型转换，但dynamic是在运行时识别对象，而object是在编译时检查类型是否错误，所以dynamic性能较快，跳过类型检查，但最好要保证转换类型正常，否则错误（实际上dynamic是编译期存在，在运行时会变为object）<br>跑题了，引用类型存放在堆上，俗称托管堆，该区域主要存放引用对象，引用存放在栈上，所以在赋值的时候值类型是多复制一个数值在栈上，引用类型只是复制一个该数据堆的引用。托管堆由GC进行管理，由此可见通常来讲引用类型是十分消耗性能的，首先创建引用在栈上，然后在堆上开辟一个新空间。但又由于其操作的是一个引用（占四个字节，包含指向数据堆的地址），相当于一个指针，所以特定情况下性能比值类型要高。<br>假如现在首先开辟了一个int类类型放在栈上，然后又创建一个object装箱该Int，则会在堆中开辟一个新空间存放该Int的数据副本。也就是说如果一个引用类型包含值类型，则该值类型是在堆上的</p>
<p>区别：1.引用类型额外有类型对象指针和同步块索引，值类型是没有的。所以我们平时使用lock 锁的对象不可能是值类型，因为值类型没有同步块索引<br>2.所有值类型都是密封的，不能继承。<br>3.值类型的复制都是全字段的复制，而引用类型只是指针的复制</p>
<p>性能方面：<br>上面也说了，值类型是复制，调用时都是全字段操作，所以调用函数、作为参数传入时值类型（struct）会进行全字段传入，是典型的值类型勿用场景<br>引用类型的初始化实际上可能会强制触发一次GC操作，所以也是相当耗性能，并且所占空间不止所有成员的和，每个成员还有内存块索引和类型对象指针<br>引用类型还有一个转换时装拆箱的性能消耗，在装箱时，首先开辟堆空间存放数据和内存索引和类型对象指针（事先在栈上存好值类型，然后复制进来堆里），然后返回地址；而拆箱则是首先获取箱子的地址，然后把值复制到栈上</p>
<p>关于应用场景：大部分情况下都是引用类型，使用值类型一般是满足以下条件<br>1：类型不会派生出其他类型<br>2：类型不需要继承其他类型<br>3：类型实例较小，不会作为方法参数，不会频繁赋值<br>4：不需要知道类型释放的通知，引用类型可以通过析构函数来得到释放通知<br>5：值不会发生改变甚至是readonly类型的时候<br>备注：<br>对于接口，接口只能包含方法名，静态只读变量，事件和索引器（？）<br>object不用多说，所有类型都直接或间接继承该类，值类型转换为这个相当于装箱，反之为拆箱。<br>string是字符串类型，该类型要说简单也简单，要说复杂也复杂，我打算专门开一篇文章讲述<br>数组也是对象，是对象的集合</p>
<p>这里提一个特殊关键字var，该类型是隐式强类型变量（相当于已经声明了该类型），但还是由编译器确定类型。</p>
<p>引用：<a href="https://www.cnblogs.com/qtiger/p/11177056.html" target="_blank" rel="noopener">https://www.cnblogs.com/qtiger/p/11177056.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/08/struct%E5%92%8Cclass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/08/struct%E5%92%8Cclass/" itemprop="url">struct和class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-08T17:00:28+08:00">
                2020-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>结构体，存储在栈上的数据类型，值类型，赋值时是全字段复制，影响一个另一个不会影响，结构里的字段除了static和const都不能直接初始化，没有无参构造函数和析构函数，结构的实例化不用New，结构不能继承或被继承，可以实现接口。在结构体初始化所有字段之前，结构体对象不可用（？）</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>类是一种引用类型，赋值时是复制一份对象的引用，可以继承基类，子类对象可以兼容父类（反之不行），类可以声明为抽象类，可以编写抽象方法，抽象类无法实例化，实现了该类的子类才可以实例化，同时可以声明为静态，当一个类是静态类时无法new。</p>
<p>ps:结构在赋值时进行复制。将结构赋值给新变量时，将复制所有数据，并且对新副本所做的任何修改不会更改原始副本的数据。在使用值类型的集合（如 Dictionary&lt;string, myStruct&gt;）时，请务必记住这一点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/27/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" itemprop="url">碰撞检测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-27T00:00:00+08:00">
                2020-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="检测方式探究"><a href="#检测方式探究" class="headerlink" title="检测方式探究"></a>检测方式探究</h2><p>一：colider or trigger<br>这两个方式应该是初学者学习用的最多的检测方式，因为的确方便，而且确实可以根据刀剑范围所可以攻击到的地方进行检测，但该方法有一个致命缺陷，就是检测次数和动画帧数和真机画面渲染次数挂钩，即是如果动画过快导致碰撞框中间出现掉帧，则在该掉帧之间的敌人便无法攻击到。</p>
<p>二：射线检测<br>射线检测即是指定位置，方向等信息发出一条射线，根据射线反馈的信息来操作物件交互，该方法常用在射击游戏里，在动作游戏中也经常用到。在本人的认知里该方法应该是最快最灵敏并且最省性能的方法了。</p>
<p>三：向量计算<br>本人采用静态变量实现的该方法，类似崩坏3中关卡内其实地形不大，敌人数量也有限，那么所有敌人可以存放在一个静态链表里，时刻检测玩家与所有敌人的位置距离，向量角度等信息。该方法可能比较消耗性能，比如攻击时也检测所有敌人的位置信息以判断是否在攻击有效范围内。</p>
<p>四：Bounds检测<br>该方法即调用unity的Bounds内置API来根据中心，半高创建一个长方体，常用其contains方法判断某个点(vector3变量)是否在长方体内。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/26/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-C#/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/26/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-C#/" itemprop="url">C#抽象类和接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-26T22:47:13+08:00">
                2020-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>将对象共用方法写出方法名和返回类型和参数，没有方法体，如果要加入成员变量，只能是静态常量</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>可以有成员变量，成员方法，方法可以是抽象或非抽象，抽象方法不能有方法体，该类不能实例化，抽象方法必须在抽象类里。</p>
<p>共同点：把对象的共性虚化<br>区别：接口只有Public，并且不方便随意增删改方法，因为会影响所有实现类，而接口如果加入非抽象方法不会影响子类。</p>
<p>使用场景探究：<br>1.如果从对象的特性来说，对象需要共用该方法，并且共用成员变量，可以考虑继承抽象类；如果仅是实现某方法，可以使用接口。<br>2.抽象类用于捕捉子类共性，而一旦一个类实现某接口，就要实现里面所有方法。</p>
<p>备注：题外话，项目中的接口和代码接口不一样，代码接口用于规范代码，项目接口属于实现一个信息处理类，让别的代码可以访问成员和方法进行调用，比如字典，字典便是实现个IConection等各个接口的方法的实现类，你可以去调用字典完成你的功能，不必关心内部实现，也可以自己写一个方法继承相关类去写一个字典类</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/%E6%B7%B1%E7%A9%B6SmoothDamp%E5%92%8CLerp%E5%87%BD%E6%95%B0-Unity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/25/%E6%B7%B1%E7%A9%B6SmoothDamp%E5%92%8CLerp%E5%87%BD%E6%95%B0-Unity/" itemprop="url">first</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-25T00:57:43+08:00">
                2020-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原本我一直以为这两个函数实际上是差不多的，lerp是线性而smooth是弧型插值，直到我心血来潮写下这两行代码<br><img src="https://raw.githubusercontent.com/leeXin183/Resources/master/Pictures/SL.png" alt="Image text"><br>按下w和d都会影响两个方向的数值，按下a或者s正常，原因至今未明</p>
<h2 id="SmoothDamp"><a href="#SmoothDamp" class="headerlink" title="SmoothDamp"></a>SmoothDamp</h2><p>弧型插值？,该函数有多个重载，其中常用的便是SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime)，其中，第三个参数为引用调用，具体作用未知，望各位看客提提意见，最后一个参数决定了缓冲时间，从from到to的时间</p>
<h2 id="Lerp"><a href="#Lerp" class="headerlink" title="Lerp"></a>Lerp</h2><p>线性插值？，官方代码注释中解释是在from和to之间用t线性插值，t在0-1之间，t为0时返回from,t为1时返回to，t为0.5返回平均值，由此可见按照当下常规用法（transform.position,targetposition,t)是容易造成最后到达一个无限逼近目标值的数字，比如99999.。。。，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" itemprop="url">观察者模式和中介者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-20T10:05:05+08:00">
                2020-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>简单来说就是有很多不同类型的对象，每个类型都有相应一系列的观察者，当被观察者发生改变，要发送通知给所有依赖于此对象的观察者通知观察者和被观察者时抽象耦合，建立一套触发机制。<br>缺点：<br>1：如果一个被观察者有很多直接和间接观察者，全部通知有点麻烦<br>2：如果观察者和被观察者有循环依赖，循环调用会导致系统崩溃<br>3：观察者只是知道被观察者发生了变化，而不知道是怎么发生变化的</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>当对象发生改变，发出通知给中介者，由中介者去发送通知给要通知的对象，中介者必须要维护场上所有对象。该设计模式也有较好的复用性和解耦，将类与类之间的关系通过中介者联合起来。<br>缺点<br>1：中介者代码量庞大，维护比较困难</p>
<h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/observer-pattern.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/unity%E6%97%8B%E8%BD%AC%E6%8E%A2%E7%A9%B61/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/unity%E6%97%8B%E8%BD%AC%E6%8E%A2%E7%A9%B61/" itemprop="url">unity旋转探究1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T00:57:43+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="坦克的炮台旋转方式"><a href="#坦克的炮台旋转方式" class="headerlink" title="坦克的炮台旋转方式"></a>坦克的炮台旋转方式</h2><p>具体需求：坦克是一个双层结构，底下一层基座，上面一层炮台，在玩家进行上下左右移动时应该旋转基座并前进指定方向，而炮台便跟随鼠标移动方向旋转</p>
<p>1.起初，我的思路是这样的，利用常用的屏幕射线到游戏场景，然后直接调用Quaternion的API–LookAt，直接看向射线点，当然这有很多问题，比如炮台在指向高低不平的地方也会上下旋转，鼠标指向敌人也会抬高炮台，如果添加rigidbody去锁定旋转轴又会导致炮台直接固定不动，直接人头分离（学姐样）。因此该方法显然行不通。</p>
<p>2.改进思路，查看Unity官方文档后发现射线可以指定忽略层级，表明忽略某一层的colider，又或者在射线检测中if嵌套检测该物体Layer是多少，以分多种判断。显然，该方法理论上应该可以实现，但是需要忽略多个层级的东西，我只需要检测地面，代码显然是非常多的，不符合我代码风格。</p>
<p>3.咱们继续改进，射线的API感觉不行了，那我们从原理入手吧，看来程序还是逃不过计算，游戏开发还是离不开3d图形学。首先，假定地面是一整个平面，就是普通的xoy二维坐标，玩家为原点，鼠标指向的点设为(x1,y1),计算玩家到目标点的向量，事先用一个temp保存玩家的方向，然后计算目标向量与当前向量的角度，然后调用Rotate函数转过去，当然理论我jio得海星，实践起来发现这玩意有亿点点问题，首先是角度限制问题，我发现Vector3.Angle函数所计算出来得角度是半角，最大只能到180度，当你鼠标转到6点钟方向再逆时针转回去角度是从180到0，简单来说，这个方法在顺时针旋转得时候可以正常，但是逆时针旋转就会硬绕一圈。所以这个方法先不考虑性能问题，代码冗余问题，首先功能就实现不了啊喂(#`O′)。</p>
<p>4.没辙了，我干脆不用什么旋转函数了，我直接设置炮台的旋转量rotation，我看你行不行。这玩意是个四元数，也就是Quaternion，这个东西臭名昭彰，难到爆炸，当年看shader女神分析这玩意的博客愣是没看懂。计算这个东西还是免了，我看看有什么直接使用的值吧，然后我看到了Quaternion.LookRotation，该函数可以直接指向一个forward向量，姑且我就理解为旋转量正前方看向该向量的方向吧，当然，通过上个方法的分析，我们可以计算出目标点和玩家的向量，那么直接调用该方法不就好了？！当然记得把y轴分量设为0，如此一来果然解决了所有问题（起码目前还没发现任何问题）。</p>
<p>总结：讲道理，踩弯路的过程是痛苦的，解决问题的时候的喜悦是无法描述的，还是得好好学习一下数学啊</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/%E9%9D%99%E6%80%81%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeeXin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/08/%E9%9D%99%E6%80%81%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81/" itemprop="url">静态与非静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-08T22:27:36+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.不加static修饰的成员是对象成员，归每个对象所有。</p>
<p>2.加static修饰的成员是类成员，可以由一个类直接调用，为所有对象共有。<br>用static关键字标识的程序元素是静态的,不用static标识的程序元素是非静态.<br>两者的区别在于:<br>静态的东西是在类型加载初始时初始化的,并且与类相关.<br>非静态东西一般放在实例的构造函数中初始化,它是与特定类的实例相关的.<br>静态方法无法调用非静态成员：</p>
<p>当New 一个对象的时候，并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后 再在堆内存中创建对象。所以说静态方法会随着类的加载而被加载。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有 new对象，而是通过类名调用该类的静态方法也可以。</p>
<p>静态方法是属于类的，动态方法属于实例对象，在类加载的时候就会分配内存，可以 通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有在对象实例化之后才存在，然后通过类的对象去访问。</p>
<p>在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</p>
<p>那类是什么时候被加载呢？在需要调用的时候被加载。</p>
<p>如果静态方法能调用动态方法的话，那如果别人通过类名调用静态方法时实例对象可能并不存在，但是方法内又调用了对象的方法，由于对象不存在，所以动态方法也不存在，程序肯定报错，所以java直接在编译阶段检查这种错误，避免运行时异常<br>为什么静态成员、静态方法中不能用this和super关键字</p>
<p>因为this代表的是调用这个函数的对象的引用,而静态方法是属于类的,不属于对象,静态方法成功加载后,对象还不一定存在 2. 在问题之前先讲super的用法：1.super的用法跟this类似，this代表对本类对象的引用，指向本类已经创建的对象；而super代表对父类对象的引用，指向父类对象；2.静态优先于对象存在；3.由上面的1.和2.知：因为静态优先于对象存在，所以方法被静态修饰之后方法先存在，而方法里面要用到g=super指向的父类对象，但是所需的父类引用对象晚于该方法出现，也就是super所指向的对象没有，当然就会出错。综上，静态方法中不可以出现super关键字。 3. 首先你要明白对象和类的区别。 this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西所有的成员方法,都有一个默认的的参数this(即使是无参的方法),只要是成员方法,编译器就会给你加上this这个参数如:<br>Class A中 void method1(){}实际上是这样的——–&gt; void method1(A this)<br>void method2(int x){}实际上是这样的——–&gt; void method2(A this, int x)<br>而静态方法与对象无关,根本不能把对象的引用传到方法中,所以不能用this 4. 在一个类中定义一个方法为static，则为静态方法，那就是说，无需本类的对象即可调用此方法，调用一个静态方法就是“类名.方法名”</p>
<p>总结：C/C++(<em>.exe)-&gt;机器java(</em>.class)-&gt;JVM-&gt;机器 这样java程序比c++运行效率低，但是因为有JVM做中介，一个操作系统下编译的*.class可以运行在其它的操作系统下，（当然要装不同操作系统下的JVM）。这是所谓的(compile once,run anywhere).</p>
<p>伪造返回类型<br>class B : A<br>    {<br>        private string s;<br>        public B(string s)<br>        {<br>            this.s = s;<br>        }<br>        public override string ToString()<br>        {<br>            return s;<br>        }<br>    }<br>class Program : A<br>    {<br>        static void Main(string[] args)<br>        {</p>
<pre><code>        B md = new B(&quot;string&quot;);
        Console.WriteLine(md);
    }
}</code></pre><p>使用 static 修饰的变量由该类的全体对象共享，意思是该类new出来的对象都可以调用该成员<br>介绍：C#的一个引用类型，delegate也翻译成委托。它实际相当于C语言中的函数指针，于指针不同的是代表是类型安全的。声明格式如下：</p>
<p>属性集 修饰符 delegate 函数返回类型 定义的代表标识符(函数形参列表);<br>其中修饰符包括new、public、protected、internal和private。</p>
<p>如：</p>
<p>public delegate int MyDelegate();  //只能代表返回类型为int，无参数的函数。<br>实例代码：</p>
<p>using System;<br>delegate int MyDelegate();  //声明一个代表</p>
<p>public class A{<br>    public int f1()  //注意要想用代表，这里返回类型必须是int，且要和声明的代表一样是无参数的<br>    {<br>        Console.WriteLine(“调用了非静态的方法”);<br>        return 0;<br>    }<br>    static public int f2(){<br>        Console.WriteLine(“调用了静态的方法”);<br>        return 0;<br>    }<br>}</p>
<p>public class Test{<br>    static void Main(){<br>        A p = new A();</p>
<pre><code>    //用new建立代表类MyDelegate对象，d中存储非静态的方法f1的地址
    MyDelegate d=new MyDelegate(p.f1);  //参数是被代表的方法
    d();//调用非静态方法

    //用new建立代表类MyDelegate对象，d中存储静态的方法f2的地址
    d=new MyDelegate(p.f2);  //参数是被代表的方法
    d();//调用静态方法
}</code></pre><p>}</p>
<p>委托对象必须使用 new 关键字来创建，且与一个特定的方法有关。</p>
<p>转载自：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LeeXin</p>
              <p class="site-description motion-element" itemprop="description">热爱游戏开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeXin</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
